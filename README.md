# SpaceClouds42's notes form learning Rust


## Basic project management

### Creating a project

```bash
cargo new project_name
cd project_name
nano main.rs
```

### Compiling

```bash
cargo build
```

Executable is generated in the `target/debug/project_name` directory. When building for a release, use `cargo build --release` so that it compiles
with optimizations. Release executables are generated in the `target/release/project_name` directory. It will take longer to compile, but the 
executable will run faster than the unoptimized build.

To test that the code can compile without generating an executable, run `cargo check`.


### Running

To run a Rust program, simply run the executable generated by compiling. To compile and run at once, run `cargo run`.


## Basic syntax

### Importing

```rust
use std::io;
```

`use` will locally bind the path provided. To import multiple items from the same path, do `use a::b::{c, d, e::f};`. That would be the equivalent
of doing the following three use declarations:

```rust
use a::b::c;
use a::b::d;
use a::b::e::f;
```

### Functions

Functions are defined by `fn function_name() { ... }`. To call a function: `function_name();`.

Macros allow for different behavior for different parameters. To call a macro: `macro_name!();`. *The same as calling functions, plus an 
exclamation mark after the macro name.*

When passing in parameters to a function, it can be by reference or by value, and you can allow or disallow the method from mutating the variable.
Using `mut ` before the parameter allows the method to mutate it. Using `&` before a parameter will make it pass by reference, (you should probably
usually use this for complex types).


### Variables

```rust
let foo = bar;

let mut x = 2;
x = 3;
```

Creates a new variable `foo` and binds it to the value of the `bar` variable. Unless otherwise specified, variables are not mutable. Using the 
`mut` keyword makes it mutable.


### Associated Functions *(aka Static Methods)*

```rust
let mut guess = String::new();
```

Functions that are implemented on a type, **rather than a particular instance of the type**, are called with the `Type::function()` syntax.


